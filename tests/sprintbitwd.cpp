#include "engine/structs/structs.h"
#include "utils/utils.h"

#include <gtest/gtest.h>

#include <iostream>

const char* BIT_NAMES[] = {
	"p0 000000000000000000000000000001",
	"p0 000000000000000000000000000010",
	"p0 000000000000000000000000000100",
	"p0 000000000000000000000000001000",
	"p0 000000000000000000000000010000",
	"p0 000000000000000000000000100000",
	"p0 000000000000000000000001000000",
	"p0 000000000000000000000010000000",
	"p0 000000000000000000000100000000",
	"p0 000000000000000000001000000000",
	"p0 000000000000000000010000000000",
	"p0 000000000000000000100000000000",
	"p0 000000000000000001000000000000",
	"p0 000000000000000010000000000000",
	"p0 000000000000000100000000000000",
	"p0 000000000000001000000000000000",
	"p0 000000000000010000000000000000",
	"p0 000000000000100000000000000000",
	"p0 000000000001000000000000000000",
	"p0 000000000010000000000000000000",
	"p0 000000000100000000000000000000",
	"p0 000000001000000000000000000000",
	"p0 000000010000000000000000000000",
	"p0 000000100000000000000000000000",
	"p0 000001000000000000000000000000",
	"p0 000010000000000000000000000000",
	"p0 000100000000000000000000000000",
	"p0 001000000000000000000000000000",
	"p0 010000000000000000000000000000",
	"p0 100000000000000000000000000000",
	"\n",
	"p1 000000000000000000000000000001",
	"p1 000000000000000000000000000010",
	"p1 000000000000000000000000000100",
	"p1 000000000000000000000000001000",
	"p1 000000000000000000000000010000",
	"p1 000000000000000000000000100000",
	"p1 000000000000000000000001000000",
	"p1 000000000000000000000010000000",
	"p1 000000000000000000000100000000",
	"p1 000000000000000000001000000000",
	"p1 000000000000000000010000000000",
	"p1 000000000000000000100000000000",
	"p1 000000000000000001000000000000",
	"p1 000000000000000010000000000000",
	"p1 000000000000000100000000000000",
	"p1 000000000000001000000000000000",
	"p1 000000000000010000000000000000",
	"p1 000000000000100000000000000000",
	"p1 000000000001000000000000000000",
	"p1 000000000010000000000000000000",
	"p1 000000000100000000000000000000",
	"p1 000000001000000000000000000000",
	"p1 000000010000000000000000000000",
	"p1 000000100000000000000000000000",
	"p1 000001000000000000000000000000",
	"p1 000010000000000000000000000000",
	"p1 000100000000000000000000000000",
	"p1 001000000000000000000000000000",
	"p1 010000000000000000000000000000",
	"p1 100000000000000000000000000000",
	"\n",
	"p2 000000000000000000000000000001",
	"p2 000000000000000000000000000010",
	"p2 000000000000000000000000000100",
	"p2 000000000000000000000000001000",
	"p2 000000000000000000000000010000",
	"p2 000000000000000000000000100000",
	"p2 000000000000000000000001000000",
	"p2 000000000000000000000010000000",
	"p2 000000000000000000000100000000",
	"p2 000000000000000000001000000000",
	"p2 000000000000000000010000000000",
	"p2 000000000000000000100000000000",
	"p2 000000000000000001000000000000",
	"p2 000000000000000010000000000000",
	"p2 000000000000000100000000000000",
	"p2 000000000000001000000000000000",
	"p2 000000000000010000000000000000",
	"p2 000000000000100000000000000000",
	"p2 000000000001000000000000000000",
	"p2 000000000010000000000000000000",
	"p2 000000000100000000000000000000",
	"p2 000000001000000000000000000000",
	"p2 000000010000000000000000000000",
	"p2 000000100000000000000000000000",
	"p2 000001000000000000000000000000",
	"p2 000010000000000000000000000000",
	"p2 000100000000000000000000000000",
	"p2 001000000000000000000000000000",
	"p2 010000000000000000000000000000",
	"p2 100000000000000000000000000000",
	"\n",
	"p3 000000000000000000000000000001",
	"p3 000000000000000000000000000010",
	"p3 000000000000000000000000000100",
	"p3 000000000000000000000000001000",
	"p3 000000000000000000000000010000",
	"p3 000000000000000000000000100000",
	"p3 000000000000000000000001000000",
	"p3 000000000000000000000010000000",
	"p3 000000000000000000000100000000",
	"p3 000000000000000000001000000000",
	"p3 000000000000000000010000000000",
	"p3 000000000000000000100000000000",
	"p3 000000000000000001000000000000",
	"p3 000000000000000010000000000000",
	"p3 000000000000000100000000000000",
	"p3 000000000000001000000000000000",
	"p3 000000000000010000000000000000",
	"p3 000000000000100000000000000000",
	"p3 000000000001000000000000000000",
	"p3 000000000010000000000000000000",
	"p3 000000000100000000000000000000",
	"p3 000000001000000000000000000000",
	"p3 000000010000000000000000000000",
	"p3 000000100000000000000000000000",
	"p3 000001000000000000000000000000",
	"p3 000010000000000000000000000000",
	"p3 000100000000000000000000000000",
	"p3 001000000000000000000000000000",
	"p3 010000000000000000000000000000",
	"p3 100000000000000000000000000000",
	"\n",
};

const char* SPLITTER = ", ";

const int PLANE_BITS = 2;

TEST(sprintbitwd, PrintZero_SimpleBitNames_NoPrintFlags)
{
	Bitvector bitvector = 0;
	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];
	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER);

	EXPECT_EQ(0, strcmp(result, "ничего"));  // "ничего" (KOI8-R)
}

TEST(sprintbitwd, SingleBit_SimpleBitNames_NoPrintFlags)
{
	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	Bitvector bitvector = 0;
	for (int plane = 0; plane < 1 << PLANE_BITS; ++plane)
	{
		constexpr int VALUES_IN_PLANE = 8 * sizeof(Bitvector) - PLANE_BITS;
		for (int i = 0; i < VALUES_IN_PLANE; ++i)
		{
			bitvector = plane << (8*sizeof(Bitvector) - PLANE_BITS)
				| Bitvector(1) << i;
			sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER);
			const int result_index = i + plane*(VALUES_IN_PLANE + 1);
			EXPECT_EQ(std::string(BIT_NAMES[result_index]), result);
		}
	}
}

TEST(sprintbitwd, AllBits_NoPrintFlags)
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n"};
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "bit1, bit2, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, "
		"UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, "
		"UNDEF, UNDEF, UNDEF, UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, AllBits_PrintFlag_0x01)
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n" };
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "a0:bit1, b0:bit2, c0:UNDEF, d0:UNDEF, e0:UNDEF, f0:UNDEF, g0:UNDEF, "
		"h0:UNDEF, i0:UNDEF, j0:UNDEF, k0:UNDEF, l0:UNDEF, m0:UNDEF, n0:UNDEF, o0:UNDEF, "
		"p0:UNDEF, q0:UNDEF, r0:UNDEF, s0:UNDEF, t0:UNDEF, u0:UNDEF, v0:UNDEF, w0:UNDEF, "
		"x0:UNDEF, y0:UNDEF, z0:UNDEF, A0:UNDEF, B0:UNDEF, C0:UNDEF, D0:UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x1);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, AllBits_PrintFlag_0x02)
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n" };
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "bit1, bit2, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x2);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, AllBits_PrintFlag_0x03)
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n" };
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "a0:bit1, b0:bit2, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, "
		"3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF, 3:UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x3);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, AllBits_PrintFlag_0x04)	// corresponds to NoPrintFlags result if there are no names leading by star
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n" };
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "bit1, bit2, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, "
		"UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, UNDEF, "
		"UNDEF, UNDEF, UNDEF, UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x04);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, AllBits_PrintFlag_0x05)	// corresponds to PrintFlag_0x01 if there are no names leading by star
{
	const char* BIT_NAMES[] = { "bit1", "bit2", "\n" };
	Bitvector bitvector = 0x3fffffff;	// 00111111 11111111 11111111 11111111
	const std::string EXPECTED = "a0:bit1, b0:bit2, c0:UNDEF, d0:UNDEF, e0:UNDEF, f0:UNDEF, g0:UNDEF, "
		"h0:UNDEF, i0:UNDEF, j0:UNDEF, k0:UNDEF, l0:UNDEF, m0:UNDEF, n0:UNDEF, o0:UNDEF, "
		"p0:UNDEF, q0:UNDEF, r0:UNDEF, s0:UNDEF, t0:UNDEF, u0:UNDEF, v0:UNDEF, w0:UNDEF, "
		"x0:UNDEF, y0:UNDEF, z0:UNDEF, A0:UNDEF, B0:UNDEF, C0:UNDEF, D0:UNDEF";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x05);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, StarBitName_NoPrintFlags)
{
	const char* BIT_NAMES[] = { "bit1", "*bit2", "bit3", "\n" };
	Bitvector bitvector = 7;
	const std::string EXPECTED = "bit1, bit3";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, StarBitName_PrintFlag_0x04)
{
	const char* BIT_NAMES[] = { "bit1", "*bit2", "bit3", "\n" };
	Bitvector bitvector = 7;
	const std::string EXPECTED = "bit1, bit2, bit3";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x04);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, UNUSED_bit_NoPrintFlags)
{
	const char* BIT_NAMES[] = { "bit1", "UNUSED", "bit3", "*UNUSED", "bit5", "UNUSED", "\n" };
	Bitvector bitvector = 0x3f;
	const std::string EXPECTED = "bit1, UNUSED, bit3, bit5, UNUSED";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, UNUSED_bit_PrintFlag_0x02)
{
	const char* BIT_NAMES[] = { "bit1", "UNUSED", "bit3", "*UNUSED", "bit5", "UNUSED", "\n" };
	Bitvector bitvector = 0x3f;
	const std::string EXPECTED = "bit1, 2:UNUSED, bit3, bit5, 6:UNUSED";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x02);

	EXPECT_EQ(EXPECTED, result);
}

TEST(sprintbitwd, UNUSED_bit_PrintFlag_0x03)
{
	const char* BIT_NAMES[] = { "bit1", "UNUSED", "bit3", "*UNUSED", "bit5", "UNUSED", "\n" };
	Bitvector bitvector = 0x3f;
	const std::string EXPECTED = "a0:bit1, b0:2:UNUSED, c0:bit3d0:, e0:bit5, f0:6:UNUSED";

	constexpr std::size_t BUFFER_SIZE = 1024;
	char result[BUFFER_SIZE];

	sprintbitwd(bitvector, BIT_NAMES, result, SPLITTER, 0x03);

	EXPECT_EQ(EXPECTED, result);
}

// vim: ts=4 sw=4 tw=0 noet syntax=cpp :
